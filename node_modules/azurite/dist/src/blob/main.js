#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Logger = tslib_1.__importStar(require("../common/Logger"));
const BlobServerFactory_1 = require("./BlobServerFactory");
const ConfigurationBase_1 = require("../common/ConfigurationBase");
const BlobEnvironment_1 = tslib_1.__importDefault(require("./BlobEnvironment"));
const Telemetry_1 = require("../common/Telemetry");
// tslint:disable:no-console
function shutdown(server) {
    const beforeCloseMessage = `Azurite Blob service is closing...`;
    const afterCloseMessage = `Azurite Blob service successfully closed`;
    Telemetry_1.AzuriteTelemetryClient.TraceStopEvent("Blob");
    console.log(beforeCloseMessage);
    server.close().then(() => {
        console.log(afterCloseMessage);
    });
}
/**
 * Entry for Azurite blob service.
 */
async function main() {
    const blobServerFactory = new BlobServerFactory_1.BlobServerFactory();
    const server = await blobServerFactory.createServer();
    const config = server.config;
    // We use logger singleton as global debugger logger to track detailed outputs cross layers
    // Note that, debug log is different from access log which is only available in request handler layer to
    // track every request. Access log is not singleton, and initialized in specific RequestHandlerFactory implementations
    // Enable debug log by default before first release for debugging purpose
    Logger.configLogger(config.enableDebugLog, config.debugLogFilePath);
    let env = new BlobEnvironment_1.default();
    (0, ConfigurationBase_1.setExtentMemoryLimit)(env, true);
    // Start server
    console.log(`Azurite Blob service is starting on ${config.host}:${config.port}`);
    await server.start();
    console.log(`Azurite Blob service successfully listens on ${server.getHttpServerAddress()}`);
    const location = await env.location();
    Telemetry_1.AzuriteTelemetryClient.init(location, !env.disableTelemetry(), env);
    await Telemetry_1.AzuriteTelemetryClient.TraceStartEvent("Blob");
    // Handle close event
    process
        .once("message", (msg) => {
        if (msg === "shutdown") {
            shutdown(server);
        }
    })
        .once("SIGINT", () => shutdown(server))
        .once("SIGTERM", () => shutdown(server));
}
main().catch((err) => {
    console.error(`Exit due to unhandled error: ${err.message}`);
    process.exit(1);
});
//# sourceMappingURL=main.js.map