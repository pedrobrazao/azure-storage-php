"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateQueryBlobWithTagsWhereFunction = void 0;
const tslib_1 = require("tslib");
const StorageError_1 = tslib_1.__importDefault(require("../../errors/StorageError"));
const StorageErrorFactory_1 = tslib_1.__importDefault(require("../../errors/StorageErrorFactory"));
const BinaryOperatorNode_1 = tslib_1.__importDefault(require("./QueryNodes/BinaryOperatorNode"));
const ExpressionNode_1 = tslib_1.__importDefault(require("./QueryNodes/ExpressionNode"));
const QueryParser_1 = tslib_1.__importDefault(require("./QueryParser"));
function executeQuery(context, queryTree) {
    let tags = {};
    const blobTags = context.tags;
    if (blobTags) {
        let blobTagsValue;
        if (typeof (blobTags) === 'string') {
            blobTagsValue = JSON.parse(blobTags);
        }
        else {
            blobTagsValue = blobTags;
        }
        blobTagsValue.blobTagSet.forEach((aTag) => {
            tags[aTag.key] = aTag.value;
        });
    }
    tags["@container"] = context.containerName;
    return queryTree.evaluate(tags);
}
exports.default = executeQuery;
function countIdentifierReferences(queryTree) {
    if (queryTree instanceof BinaryOperatorNode_1.default) {
        return 1;
    }
    if (queryTree instanceof ExpressionNode_1.default) {
        return countIdentifierReferences(queryTree.child);
    }
    return 0;
}
function generateQueryBlobWithTagsWhereFunction(requestContext, query, conditionHeader) {
    if (query === undefined) {
        return () => {
            return [];
        };
    }
    const queryTree = (0, QueryParser_1.default)(requestContext, query, conditionHeader);
    // Validates that the provided query tree represents a valid query.
    // That is, a query containing at least one conditional expression,
    // where every conditional expression operates on at least
    // one column or built -in identifier(i.e.comparison between two constants is not allowed).
    const identifierReferencesCount = countIdentifierReferences(queryTree);
    if (identifierReferencesCount == 0) {
        if (conditionHeader === undefined) {
            throw new StorageError_1.default(400, `InvalidQueryParameterValue`, `Error parsing query at or near character position 1: expected an operator`, requestContext.contextId, {
                QueryParameterName: `where`,
                QueryParameterValue: query
            });
        }
        else {
            throw StorageErrorFactory_1.default.getInvalidHeaderValue(requestContext.contextId, {
                HeaderName: conditionHeader,
                HeaderValue: query
            });
        }
    }
    return (entity) => executeQuery(entity, queryTree);
}
exports.generateQueryBlobWithTagsWhereFunction = generateQueryBlobWithTagsWhereFunction;
//# sourceMappingURL=QueryInterpreter.js.map